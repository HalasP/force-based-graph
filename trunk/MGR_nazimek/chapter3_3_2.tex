
\subsection{Aplikacja mobilna}

Cech¹ wyró¿niaj¹c¹ podejœcie prezentowane w niniejszej pracy od typowych
rozwi¹zañ problemu integracji systemów enterprise jest sposób generowania
interfejsu u¿ytkownika. W typowym podejœciu po stronie aplikacji mobilnej mamy
do czynienia z raz zdefiniowanym przez programistê uk³adem oraz wygl¹dem
interfejsu graficznego. Wi¹¿e siê to bezpoœrednio ze sposobem pisania aplikacji,
w którym programista ma do dyspozycji gotowe komponenty UI, które musz¹ zostaæ
odpowiednio oprogramowane i wkompilowane w koñcow¹ wersjê aplikacji mobilnej.
To powoduje, ¿e jakiekolwiek zmiany w interfejsie s¹ mo¿liwe tylko i wy³¹cznie
poprzez przebudowê aplikacji. A co za tym idzie tak¿e i ponowne rozprowadzenie
tak zmienionego programu. Takie podejœcie generuje dodatkowe koszty, wynikaj¹ce
z potrzeby zapewnienia dostarczenia aktualnej wersji aplikacji do wszystkich
klientów, posiadaj¹cych jej star¹ wersjê. Czêœciowo problem ten rozwi¹zuje
podejœcie, anga¿uj¹ce cienkiego klienta w postaci mobilnej przegl¹darki
internetowej. Zapewnia ono centralizacjê aplikacji, przez co wdro¿enie nowych
wersji staje siê niemal automatyczne. Niestety, rozwi¹zanie tego typu jest
czêsto niewystarczaj¹co elastyczne oraz posiada s³abo rozbudowany interfejs
u¿ytkownika. 
W niniejszej pracy wykorzystane zosta³o podejœcie poœrednie, bêd¹ce czymœ
pomiêdzy interfejsem generowanym przez przegl¹darki internetowe, a
pe³nowartoœciowym interfejsem aplikacji mobilnych. 
\subsubsection{Dynamicznie generowany interfejs u¿ytkownika}
W odró¿nieniu od typowej aplikacji dostêpnej na urz¹dzeniach mobilnych, nasza
aplikacja nie posiada zdefiniowanego z góry interfejsu u¿ytkownika. Za
wyj¹tkiem g³ównego ekranu, wszystkie pozosta³e s¹ generowane na podstawie
danych, przesy³anych z serwera. System zachowuje siê analogicznie do
przegl¹darki internetowej - renderuje znaczniki interfejsu u¿ytkownika. W
odró¿nieniu od rozwi¹zañ opartych na przegl¹darce, mamy mo¿liwoœæ zmian w
kodzie Ÿród³owym aplikacji renderuj¹cej, dziêki czemu, w zale¿noœci od
potrzeby, mo¿emy dostosowywaæ zachowanie programu do wymagañ u¿ytkownika. Nasza
aplikacja nie jest ograniczona przez niemodyfikowaln¹ przegl¹darkê internetow¹.
\index{Kuix}
\subsubsection{Kuix}
Opisany w poprzednim rozdziale dynamicznie generowany interfejs jest mo¿liwy do
osi¹gniêcia w œrodowisku J2ME przy u¿yciu pewnego, danego z góry, uniwersalnego
sposobu opisu wygl¹du poszczególnych elementów aplikacji. Ze wzglêdu na
popularnoœæ XML oraz wsparcie dla tego jêzyka, zarówno po stronie urz¹dzeñ, jak
i serwerów, mo¿na przyj¹æ, ¿e w³aœnie w nim opisany zostanie interfejs
u¿ytkownika. Po stronie serwera, na podstawie informacji z bazy danych, budowany
bêdzie dokument XML, ³¹cz¹cy dane z ich sposobem wizualizacji. Po stronie
urz¹dzenia mobilnego, dokument ten zostanie przetworzony przez parser XML, a
nastêpnie jego poszczególne elementy zostan¹ zmapowane na odpowiadaj¹ce im
elementy interfejsu J2ME (odpowiednio rozszerzone o dodatkowe komponenty,
niedostêpne w standardowej wersji tego œrodowiska). Opisana powy¿ej procedura
zosta³a zaimplementowana w szkielecie programistycznym kuix.
\subsubsection{Cechy szkieletu Kuix}
Model programistyczny, oferowany przez szkielet Kuix, znacznie ró¿ni siê od
innych rozwi¹zañ spotykanych na platformach mobilnych. Posiada on wiele cech
charakterystycznych dla lekkiego modelu tworzenia oprogramowania mobilnego -
opartego o mobiln¹ przegl¹darkê internetow¹. Najlepsz¹ ilustracj¹ zasady
dzia³ania tego szkieletu, jest przyk³adowa aplikacja, wiêc w dalszej czêœci
pracy zostanie przedstawiony krótki, przyk³adowy program, obrazuj¹cy podstawowe
idee.

\paragraph{HelloKuix}

Na rysunku \ref{fig:kuix_structure} widoczna jest struktura bardzo prostego programu,
posiadaj¹cego wszystkie cechy dostarczane przez szkielet Kuix.

\begin{figure}[htb]
    \begin{center}
    \includegraphics[angle=0,scale=0.7]{img/kuix_structure.png}
    \end{center}
    \caption{Struktura prostego projektu wykorzystuj¹cego szkielet Kuix}
    \label{fig:kuix_structure}
\end{figure}


Poza standardowymi plikami *.java zawieraj¹cymi kod aplikacji nale¿y tu zwróciæ
uwagê na dodatkowe pliki zasobów :
\begin{itemize}
  \item helloworld.css
  \item helloworld.xml
\end{itemize}

Plik helloworld.xml to dokument XML we wspomnianym wczeœniej formacie,
reprezentuj¹cym dane wraz ze sposobem ich wizualizacji. 

\begin{verbatim}
<screen title="helloworld">
    <container 
		style="layout:inlinelayout(false,fill); align: center">
        	<text text="Hello World!" />
        	<picture src="logo_community.png" />
    </container>
</screen>
\end{verbatim}

Tag screen to pojedynczy ekran na urz¹dzeniu mobilnym, mog¹cy posiadaæ jeden,
b¹dŸ wiêcej, tak zwanych widgetów - elementów interfejsu u¿ytkownika. Powy¿szy
przyk³ad zawiera kontener (container), czyli pojemnik widgetów, pozwalaj¹cy na
grupowanie ich w odrêbne uk³ady. W pojemniku znajduje siê tekst (tag text) oraz
obazek (tag picture). Informacje o zawartoœci oraz cechach
poszczególnych elementów przekazywane s¹ za pomoc¹ atrybutów.

Powy¿szy plik xml jest wczytywany na pocz¹tku dzia³ania programu. S³u¿y do tego
kod widoczny poni¿ej.

\begin{verbatim}
// Load the content from the XML 
// file with Kuix.loadScreen static method
Screen screen = Kuix.loadScreen("helloworld.xml", null);

// Set the application current screen  
screen.setCurrent();
\end{verbatim}

Jak widaæ z za³¹czonego przyk³adu, budowanie elementów interfejsu oraz ich
wczytywanie jest bardzo proste i w pewien sposób przypomina tworzenie
interfejsu u¿ytkownika dla stron wyœwietlanych w przegl¹darkach inernetowych.
\index{CSS}
\paragraph{CSS, a Kuix}
Charakterystycznym elementem zapo¿yczonym przez Kuix z technologii
internetowych jest sposób nadawania po¿¹danego wygl¹du elementom aplikacji.
S³u¿¹ do tego kaskadowe arkusze stylów (Cascading Style Sheets). W przyk³adzie
z poprzedniego paragrafu plik helloworld.css wygl¹da nastêpuj¹co :

\begin{verbatim}
text {
    align: center;
    font-style: normal;
    color: #f19300;
}
screenTopbar text {
    color: white;
    padding: 1 2 1 2;
}
screenTopbar {
    font-style: bold;
    bg-color: #cccccc;
    border: 0 0 1 0;
    border-color: #f19300;
}
desktop {
    bg-color: #444447;
}
\end{verbatim}

Powy¿szy kod CSS praktycznie niczym siê nie ró¿ni od tego, spotykanego w
projektach pisanych pod standardowe przegl¹darki internetowe.
Do ka¿dego elementu interfejsu, takiego jak ekran, czy pulpit (screen, desktop)
mamy przypisane odpowiednie selektory. Na przyk³ad, by nadaæ styl paskowi
tytu³owemu ekranu, u¿ywamy selektora screenTopbar.

By za³adowaæ do systemu plik CSS, znajduj¹cy siê w zasobach projektu, nale¿y
u¿yæ statycznej metody loadCSS klasy Kuix:

\begin{verbatim}
// Load the stylesheet from the CSS-like file with 
// Kuix.loadCss static method
//  note: a stylesheet is not associated with 
//		  a screen but with the midlet
//  note 2: by default '/css/' folder is use 
//			to find the 'helloworld.css' file
Kuix.loadCss("helloworld.css");
\end{verbatim}

Koñcowy efekt po³¹czenia pliku XML ze stylami CSS widoczny jest na rysunku
\ref{fig:kuix_helloworld}.

\begin{figure}[htb]
    \begin{center}
    \includegraphics[angle=0,scale=0.7]{img/kuix_helloworld.png}
    \end{center}
    \caption{Wygl¹d omawianej aplikacji}
    \label{fig:kuix_helloworld}
\end{figure}


W analogiczny sposób mo¿na równie ³atwo dodaæ podrêczne menu do aplikacji :

\begin{verbatim}
    <screenFirstMenu>Exit</screenFirstMenu>
    <screenSecondMenu>
        more...
        <menuPopup>
            <menuItem>
                About
            </menuItem>
            <menuItem>
                Exit
            </menuItem>
        </menuPopup>
    </screenSecondMenu> 
\end{verbatim}

Efekt koñcowy wraz z menu dostêpnym pod prawym przyciskiem (tak zwane Second
Menu) widzimy na rysunku \ref{fig:kuix_helloworld2}

\begin{figure}[htb]
    \begin{center}
    \includegraphics[angle=0,scale=0.7]{img/kuix_helloworld2.png}
    \end{center}
    \caption{Wygl¹d omawianej aplikacji}
    \label{fig:kuix_helloworld2}
\end{figure}


\paragraph{Problemy}

W chwili pisania niniejszej pracy œrodowisko Kuix by³o nowoœci¹ na rynku.
Najbardziej aktualna wersja 1.01 zawiera nadal du¿o wad i b³êdów. Z wykonanych
przez nas testów wynika, ¿e najwiêksze problemy zwi¹zane s¹ z pewnymi
przek³amaniami graficznymi, które mo¿na spotkaæ na urz¹dzeniach mobilnych firmy
Nokia. B³êdy te nie utrudnia³y pracy, a jedynie pozostawia³y wra¿enie
ogólnego niedopracowania obecnej wersji szkieletu. Nale¿y spodziewaæ siê, ¿e
zostan¹ usuniête w nastêpnych wersjach. 
\newline
Kolejnym powa¿nym problem zwi¹zanym ze szkieletem jest uboga dokumentacja
techniczna. Dobrze i szczegó³owo wykonana jest jedynie dokumentacja w
formie javadoc oraz kursy wprowadzaj¹ce do tematyki. Niestety, na ich podstawie
mo¿na opanowaæ jedynie elementarne zasady pos³ugiwania siê œrodowiskiem. Jednak,
dziêki dostêpnoœci kodu Ÿród³owego (Kuix jest w pe³ni otwarty), mo¿liwe jest
zapoznanie siê z nieudokumentowanymi funkcjami oraz ewentualne
wprowadzenie w³asnych poprawek.
\newline
Bardzo uci¹¿liwym problemem jest rozmiar skompilowanych bibliotek œrodowiska
Kuix. Na chwilê obecn¹ jest to oko³o 250 kilobajtów. Niestety wiele urz¹dzeñ,
w które zosta³a wbudowana wirtualna maszyna Java, ogranicza dopuszczalny
rozmiar plików jar. Najczêœciej ograniczenie to oscyluje w okolicach 100-150 kilobajtów,
przez co niemo¿liwe jest wykorzystanie Kuix na tych platformach. Problem ten dotyczy g³ównie rozwi¹zañ konsumenckich, gdy¿ w rozwi¹zaniach mobilnych dla biznesu ograniczenia s¹ du¿o wy¿sze lub mo¿liwe jest dzielenie programu na biblioteki(takie rozwi¹zanie mo¿na znaleŸæ na
platformie Blackberry).
